# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm|xterm-color|*-256color) color_prompt=yes;;
esac

# Setup cache file
CACHE_FILE=$XDG_CACHE_HOME/bash/prompt_config
[ ! -d $XDG_CACHE_HOME/bash ] && mkdir -p $(dirname $CACHE_FILE) &> /dev/null
[ ! -f $CACHE_FILE ] && cat >> $CACHE_FILE << EOF
SHOW_GIT_INFO="no"
ML_PROMPT="no"
R_ALIGNED="no"
EXIT_CODE_SETTING="no"
SIMPLE_PROMPT="no"
SHOW_FULL_PATH="no"
EOF
. $CACHE_FILE

# Variables to set to activate different prompts:
# SHOW_GIT_INFO="yes"      -- show git information on prompt
# ML_PROMPT="yes"          -- multiline prompt
# R_ALIGNED="yes"          -- have right aligned information as well
# EXIT_CODE_SETTING="yes"  -- have the last exit code in the prompt
# SIMPLE_PROMPT="path|yes" -- display prompt in a simple matter
# SHOW_FULL_PATH="yes"     -- display full path in prompt

toggle_git_info () {
    OLD_SHOW_GIT_INFO=$SHOW_GIT_INFO
    [ "$SHOW_GIT_INFO" = "yes" ] && SHOW_GIT_INFO="no" || \
        SHOW_GIT_INFO="yes"
    (grep SHOW_GIT_INFO $CACHE_FILE &> /dev/null &&
        sed -i "s/SHOW_GIT_INFO=\"$OLD_SHOW_GIT_INFO\"/SHOW_GIT_INFO=\"$SHOW_GIT_INFO\"/" \
        $CACHE_FILE) || \
        echo "SHOW_GIT_INFO=\"$SHOW_GIT_INFO\"" >> $CACHE_FILE
}
alias cp-tgi=toggle_git_info

toggle_multiline_prompt () {
    OLD_ML_PROMPT=$ML_PROMPT
    [ "$ML_PROMPT" = "yes" ] && ML_PROMPT="no" || \
        ML_PROMPT="yes"
    (grep ML_PROMPT $CACHE_FILE &> /dev/null &&
        sed -i "s/ML_PROMPT=\"$OLD_ML_PROMPT\"/ML_PROMPT=\"$ML_PROMPT\"/" \
        $CACHE_FILE) || \
        echo "ML_PROMPT=\"$ML_PROMPT\"" >> $CACHE_FILE
}
alias cp-tmp=toggle_multiline_prompt

toggle_right_aligned () {
    OLD_R_ALIGNED=$R_ALIGNED
    [ "$R_ALIGNED" = "yes" ] && R_ALIGNED="no" || \
        R_ALIGNED="yes"
    (grep R_ALIGNED $CACHE_FILE &> /dev/null &&
        sed -i "s/R_ALIGNED=\"$OLD_R_ALIGNED\"/R_ALIGNED=\"$R_ALIGNED\"/" \
        $CACHE_FILE) || \
        echo "R_ALIGNED=\"$R_ALIGNED\"" >> $CACHE_FILE
}
alias cp-tra=toggle_right_aligned

toggle_exit_code () {
    OLD_EXIT_CODE_SETTING=$EXIT_CODE_SETTING
    [ "$EXIT_CODE_SETTING" = "yes" ] && EXIT_CODE_SETTING="no" || \
        EXIT_CODE_SETTING="yes"
    (grep EXIT_CODE_SETTING $CACHE_FILE &> /dev/null && \
        sed -i "s/EXIT_CODE_SETTING=\"$OLD_EXIT_CODE_SETTING\"/EXIT_CODE_SETTING=\"$EXIT_CODE_SETTING\"/" \
        $CACHE_FILE) || \
        echo "EXIT_CODE_SETTING=\"$EXIT_CODE_SETTING\"" >> $CACHE_FILE
}
alias cp-tec=toggle_exit_code

toggle_simple_prompt () {
    OLD_SIMPLE_PROMPT=$SIMPLE_PROMPT
    if [ "$SIMPLE_PROMPT" = "yes" ]
    then
        SIMPLE_PROMPT="path"
    elif [ "$SIMPLE_PROMPT" = "path" ]
    then
        SIMPLE_PROMPT="no"
    else
        SIMPLE_PROMPT="yes"
    fi
    (grep SIMPLE_PROMPT $CACHE_FILE &> /dev/null && \
        sed -i "s/SIMPLE_PROMPT=\"$OLD_SIMPLE_PROMPT\"/SIMPLE_PROMPT=\"$SIMPLE_PROMPT\"/" \
        $CACHE_FILE) || \
        echo "SIMPLE_PROMPT=\"$SIMPLE_PROMPT\"" >> $CACHE_FILE
}
alias cp-tsp=toggle_simple_prompt

toggle_full_path () {
    OLD_SHOW_FULL_PATH=$SHOW_FULL_PATH
    [ "$SHOW_FULL_PATH" = "yes" ] && SHOW_FULL_PATH="no" || \
        SHOW_FULL_PATH="yes"
    (grep SHOW_FULL_PATH $CACHE_FILE &> /dev/null && \
        sed -i "s/SHOW_FULL_PATH=\"$OLD_SHOW_FULL_PATH\"/SHOW_FULL_PATH=\"$SHOW_FULL_PATH\"/" \
        $CACHE_FILE) || \
        echo "SHOW_FULL_PATH=\"$SHOW_FULL_PATH\"" >> $CACHE_FILE
}
alias cp-tfp=toggle_full_path

customize_prompt () {
    echo -e "Which part do you want to customize:" \
        "\n\t1) git info\n\t2) multiline\n\t3) right aligned\n\t4) exit code string" \
        "\n\t5) simple prompt"
    read option

    case "$option" in
        1)
            toggle_git_info
            ;;
        2)
            toggle_multiline_prompt
            ;;
        3)
            toggle_right_aligned
            ;;
        4)
            toggle_exit_code
            ;;
        5)
            toggle_simple_prompt
            ;;
        *)
            echo "Not a valid option"
            return 1
            ;;
    esac
}
alias cp-i=customize_prompt

# Color codes are \033[<code>m
# The brackets (\[ and \]) are for using color codes in a prompt.
# They tell bash that they are non-printing characters. They make
# the prompt not do weird things.
FULL_RESET="\[\033[0m\]"
FG_RESET="\[\033[39m\]"

PURPLE="\[\033[35m\]"
GREEN="\[\033[32m\]"
RED="\[\033[31m\]"
YELLOW="\[\033[33m\]"
CYAN="\[\033[36m\]"

GREEN_BG="\[\033[0;42;30m\]"
FULL_BG="\[\033[48;5;11m\]"

SINGLE_LINE_PROMPT="[$GREEN$SHLVL$FULL_RESET]─[$GREEN\t$FULL_RESET]─[$PURPLE\u$FULL_RESET@$YELLOW\h$FULL_RESET]"

dir_is_git_repo () {
    git rev-parse --is-inside-work-tree &> /dev/null
}

join_by () { local IFS="$1"; shift; echo "$*"; }

get_length_of_non_color_parts () {
    declare -a ARRAY_VAR=("${!1}")
    local ARRAY_VAR_STRING_LEN=0
    for index in ${!ARRAY_VAR[*]}
    do
        [ "$(($index % 2))" = "0" ] && \
            ARRAY_VAR_STRING_LEN=$(($ARRAY_VAR_STRING_LEN + \
                ${#ARRAY_VAR[$index]}))
    done
    echo -n $ARRAY_VAR_STRING_LEN
}

calculate_compensation () {
    # assumes PS1R and PS1R_COMPENSATION both exist
    for (( i = 0; i < ${#PS1R}; i++ ))
    do
        [ "${PS1R:$i:1}" = "\\" ] && START_COUNT=1

        # Add in the time (8 characters for the time, - 6 because
        # 2 characters represent the time (\t)
        [ $START_COUNT -eq 1 ] && [ "${PS1R:$(($i+1)):1}" = "t" ] && \
            PS1R_COMPENSATION=$(( $PS1R_COMPENSATION - 6 )) && \
            i=$(( $i + 1 )) && START_COUNT=0

        # Add color codes
        [ $START_COUNT -eq 1 ] && \
            PS1R_COMPENSATION=$(( $PS1R_COMPENSATION + 1 )) && \
            [ "${PS1R:$i:1}" = "]" ] && START_COUNT=0
    done
}

setup_git_info () {
    if [ "$SHOW_GIT_INFO" = "yes" ]
    then
        local IS_GIT_REPO=$(dir_is_git_repo; echo $?)
        [ $IS_GIT_REPO -eq 0 ] && [ -n "$(timeout 2 git status -uno --short 2> /dev/null)" ] && \
            GIT_STATUS=" *"
        [ $IS_GIT_REPO -eq 0 ] && GIT_INFO=(" (" "$GREEN" \
            "$(timeout 2 git branch | grep "\*" | rev | cut -d' ' -f1 | rev | \
                cut -d')' -f1)" "$FG_RESET" ")" "$RED" "$GIT_STATUS" "$FG_RESET")
    fi
}

multiline_prompt () {
    # The different parts of PS1
    local SHLVL_INFO=(" (" "$GREEN" "$SHLVL" "$FG_RESET" ")")
    local PRMPT_HOOK=(" " "$GREEN" "┌─" "$FG_RESET")
    local PC_INFO=("[" "$PURPLE" "$USER" "$FG_RESET" "@" "$YELLOW" "$HOSTNAME" "$FG_RESET" "]")
    local DIR_INFO=("[" "$CYAN" "$([ "$SHOW_FULL_PATH" = "yes" ] && echo $(echo $PWD | sed -e "s|$HOME|~|") || echo $(basename $PWD))" "$FG_RESET" "]")
    local GIT_INFO=
    local GIT_STATUS=
    local DATE_INFO=

    # Create the git info part
    setup_git_info
    [ "$EXIT_CODE_SETTING" = "yes" ] && \
        PROMPT_EXIT_CODE_STR=-[$PROMPT_EXIT_CODE] || PROMPT_EXIT_CODE_STR=

    # Set up the different parts of the prompt (left side, right side, prompt)
    local PS1R="$FG_RESET[$GREEN\t$FULL_RESET]"
    [ "$R_ALIGNED" != "yes" ] && DATE_INFO="$GREEN─$PS1R"
    local PS1L="$(join_by "" "${SHLVL_INFO[@]}")$(join_by "" "${PRMPT_HOOK[@]}")$(join_by "" "${PC_INFO[@]}")$(join_by "" "${DIR_INFO[@]}")$DATE_INFO$PROMPT_EXIT_CODE_STR$(join_by "" "${GIT_INFO[@]}")"
    local PS1_PRMPT="    $GREEN└─$FG_RESET$EXIT_COLOR■$FULL_RESET "

    # Get the length of the left side of PS1
    local PS1L_LEN=0
    if [ "$R_ALIGNED" = "yes" ]
    then
        PS1L_LEN=$(($PS1L_LEN + $(get_length_of_non_color_parts SHLVL_INFO[@])))
        PS1L_LEN=$(($PS1L_LEN + $(get_length_of_non_color_parts PRMPT_HOOK[@])))
        PS1L_LEN=$(($PS1L_LEN + $(get_length_of_non_color_parts PC_INFO[@])))
        PS1L_LEN=$(($PS1L_LEN + $(get_length_of_non_color_parts DIR_INFO[@])))
        PS1L_LEN=$(($PS1L_LEN + $(get_length_of_non_color_parts GIT_INFO[@])))
        PS1L_LEN=$(($PS1L_LEN + $(get_length_of_non_color_parts PROMPT_EXIT_CODE_STR)))
    else
        PS1R=
        PS1L_LEN=$COLUMNS
    fi

    # Add in the amount to account for escaped sequences
    local START_COUNT=0
    local PS1R_COMPENSATION=0
    [ "$R_ALIGNED" = "yes" ] && calculate_compensation

    # Put it all together now
    PS1="`printf "%s%$((${COLUMNS}-${PS1L_LEN}+${PS1R_COMPENSATION}))s\n%s" "$PS1L" "$PS1R" "$PS1_PRMPT"`"
}

singleline_prompt () {
    local GIT_INFO=
    local GIT_STATUS=

    setup_git_info

    [ "$EXIT_CODE_SETTING" = "yes" ] && \
        PROMPT_EXIT_CODE_STR=-[$PROMPT_EXIT_CODE] || PROMPT_EXIT_CODE_STR=
    PS1=" $SINGLE_LINE_PROMPT─[$CYAN$([ "$SHOW_FULL_PATH" = "yes" ] && echo -n '\w' || echo -n '\W')$FULL_RESET]$PROMPT_EXIT_CODE_STR$GREEN-$EXIT_COLOR■$FULL_RESET$(join_by "" "${GIT_INFO[@]}") "
}

simple_prompt () {
    [ "$SIMPLE_PROMPT" = "yes" ] && PS1=" $EXIT_COLOR\$$FULL_RESET "
    [ "$SIMPLE_PROMPT" = "path" ] && PS1=" $CYAN$([ "$SHOW_FULL_PATH" = "yes" ] && echo -n '\w' || echo -n '\W')$FULL_RESET $EXIT_COLOR\$$FULL_RESET "
}

# TODO(Grant): git rev-parse --verify --quiet refs/stash >/dev/null
prompt () {
    # This has to be first. I need to get the exit code of the last command ran
    # local EXIT="$?"
    PROMPT_EXIT_CODE="$?"
    local EXIT_COLOR=$GREEN

    if [ $PROMPT_EXIT_CODE != 0 ]
    then
        EXIT_COLOR=$RED
    fi

    if [ "$SIMPLE_PROMPT" != "no" ]
    then
        simple_prompt
    else
        [ "$ML_PROMPT" = "yes" ] && multiline_prompt || singleline_prompt
    fi
}

PROMPT_COMMAND='prompt'
